2019.9.11
1、Android开发的两种方式。Eclipse + ADT + Android SDK。 或者使用Android Studio开发。
2、Android项目结构。

    .gradel和.idea自动生成的文件夹，不用管。
    app，项目的主要文件加。
        build，存放编译时候生成的文件，不用关心。
        libs，存放项目中使用的第三方jar包。该包下的内容会自动添加到构建路径中去。
        src，资源文件。
            androidTest，编写测试代码。
            main，主要文件。
                java，存放java代码。
                res，存放资源文件。存放图片、图标、布局、配置等。
                    drawable、存放图片。
                    layout、存放布局。
                    menu，以前有物理按键的时候会用到。
                    mimap、存放app图标。
                    values、存放字符串、样式、颜色等配置。
            AndroidManifest.xml，项目的配置文件。
         .gitignore，版本控制的忽略文件。
         app.iml，自动生成，不需要关系。
         build.gradle（和xcode中，info.plist很想）， app模块中gradel构建版本，里面有很多gradel配置项。包括版本号、appid等。
         proguard-rules.pro， 用于代码混淆的规则。
     gradle，用于构建版本的。
     .gitignore，版本控制中忽略文件。
     local.properties， 指定Android SDK的路径。
     settings.gradle，指定项目中引入的模块。

  从上面的目录结构发现，在app目录下和整个项目的目录下都有共同的文件，比如.gitinignor、build.gradle、xx.iml等。其实我们可以理解为，
  xcode中，project和target的关系。app目录下，就相当于项目的一个target。所以作用域，我们也要了解。
3、构建apk。Build->Generate Signed Bundle/Apk。 其中涉及到签名秘钥.jks文件。

2019.9.16
1、安卓中dp和ios中pt的区别。
    pt和px的关系，和设备有很大关系，现在ios设备最低都是1pt = 2*2px， plus设备都是1pt = 3*3px。
    dp和px的关系，和设备有关。
    屏幕模式        像素密度           换算关系           分辨率
     ldpi          120dpi           1dp = 0.75px      240*320    // 现在几乎没有这种设备
     mdpi          160dpi           1dp = 1px         320*480    // 现在几乎没有这种设备
     hdpi          240dpi           1dp = 1.5px       480*800    // 现在几乎咩有这种设备
     xhdpi         320dpi           1dp = 2px         720*1280
     xxhdpi        480dpi           1dp = 3px         1080*1920
     xxxhdpi       640dpi           1dp = 4px         1440*2560

     苹果的pt和工业印刷的pt是不同的，ios中 1pt = 1/163 英尺。（工业印刷1pt = 72 inch）。
     android中，1dp = 1/160英尺。所以，ios中100长度，和 Android 100物理长度差不过，约等于0.15毫米。但是相对应的像素就很不一样了，
     明显android的对于像素更大。


2、LineLayout线性布局。
    id：类似ios，tag。
    gravity： 子控件对其方式。
        注意点：如果父控件gravity是horizon，那么子控件只能设置gravity垂直方向才有效果。
               如果父控件gravity是verify，那么子控件只能设置gravity是水平方向才有效果。
    layout_gravity： 相对于父控件对其方式。
    layout_wight/height: 宽/高
    layout_weight: 权重。
    backgrout: 背景，颜色或者图片

    padding/margin: 间距。

    divider： 分割线。 颜色或者图片。
    showDiveiders： 分割线位置。
    dividerPading: 分割线padding。

3、RelativeLayout相对布局。

2019.9.17
1、TableLayout。列表布局。
    特点：从上往下排列。row的数量就是我们写的控件数量。 colums列的数量需要搭配TableRow来使用。
        宽度一定是和父控件相同。
        可是设置隐藏列、拉伸列、缩小列。
2、FrameLayout。帧布局。使用场景比较少。
    特点： 子控件都是从左上开始布局。
    可以设置foreground的一些属性。
3、GridLayout。表格。
    特点： 设置row、colum设置行列。
    子控件，通过rowSpan、columSpan、rowWeight、columnWeight来控制其大小。通过row、colum来控制其位置。
    当然还有一个属性gravity属性。
4、AbsoluteLayout。绝对布局。几乎不会用到。
    其特点就是，如果设置位置、大小，不会跟着机型的改变而改变。
5、TextView，类似ios中UILable。
    常用属性，布局layout开头，
    gravity文本对其。
    text、textSize、textStyle（加粗|斜体）、textColor等。
    shadowDx、shadowDy、shadowColor设置阴影。
    边框设置其原理:
        设置shapeDrawable，然后将TextView的backgroud设置成该资源。
    设置drawable，文字+图片。如果想要设置图片，需要java代码实现。
    设置下划线。通过getPaint().setFlags来实现。
    或者是富文本。SpannadbleString。类似NSAttributeString。 其中重要属性，就是各种Span。
    常见的。。
    ForegroundColorSpan：前景色
    BackgroundColorSpan：背景色
    ClickableSpan：抽象类，可点击效果，重写onClick方法响应点击事件
    UnderlineSpan：下划线
    StrikeThroughSpan：删除线
    AbsoluteSpan：文字绝对大小
    URLSpan：超链接
    MaskFilterSpan：EmbossMaskFilter浮雕效果，BlurMaskFilter模糊效果
    RelativeSpan：文字相对大小
    ScaleXSpan：x轴缩放
    styleSpan：文字样式
    TypefaceSpan：文字字体类型
    TextApearanceSpan：文字外貌
    SuperscriptSpan：上标
    SubscriptSpan：下标
    ImageSpan：图片

2019.9.18
1、EditeText文本输入。继承TextView。
    其输入样式（是否是多行、键盘样式、大小写等）inputType。
    focuseAble和FocuseAbleInmodel的区别。focusAble用键盘是否能获取焦点。FocuseAbleInModel用软键盘是否能获取焦点。
    hint。
    textxxxx。
    imeOptions。enter键样式。
    监听方式，1、onFocusChangeLisent。2、addTextChangeLisent。
2、Button的使用。其中使用StateListDrawAble对相应状态进行设置。
    button也能进行监听，继承自TextView。
    setClick进行按钮点击监听。
3、ImageButton。src设置资源。继承ImageView。
4、RadioButton。配合RadioGroup使用。 设置图片，button = "@null" // 屏蔽默认效果。 drawableLeft 添加drawAble样式。

2019.9.19
1、drawable 自定义backgroud。常见控件shape、selector|item、bitmap（图片）。RadioButton中，selector其实是checked。
2、ImageView，中src对应的image，其中scaleType能够控制显示。
    其中fitxx会是图片进行缩放后，不超过ImageView的情况下添加。
    这个和centerxx是不同的。
3、ToggleButton。textOn、TextOff的使用。
4、注意，自定义drawable的使用场景。

2019.9.20
1、Switch的使用。可以设置thumb、track的样式。
2、ProgressBar可以是圆环或者是线性的。
3、SeekBar类似ios中，Slide。 其样式通过drawable来进行设置。使用Layer-list 注意需要通过设置backgroud、seconderayProgress、progress来实现。
4、RatingBar，间接继承progressBar。
5、Constraints在性能和灵活方面都是优于RelativeLayout。可以配合Barrier（设置栅栏）、Group（便于隐藏）、Placehold（占位）、GuidLine（辅助线）。
    其gone的使用，也就是当相对控件gone的时候，其显示方式。

9.21
1、jvm和dvm。
    jvm是java虚拟机，也就是java程序想要运行需要基于该虚拟机，其作用是将 .java->.class->.jar
        注意jdk（java development kit）、jre（java runtime environment）和jvm（java virtual machine）的区别。
        在JDK的安装目录里你会发现有jre目录，jre目录中有文件夹bin和lib,在这里可以认为bin里的文件就是jvm，他们很多都是.exe/.dll结尾（windows下），
        所以它是可执行程序(JVM)，lib中则是jvm工作所需要的类库，可以看到很多.jar文件，而jvm和lib合起来就是jre了。
        所以，在你写完java程序编译成.class之后，把.class文件和jre一起打包，然后再写一个用来引导程序启动的cmd文件，再一起打包，
        这样你就可以在其他没有安装jre的windows运行你写程序了（jre里有运行.class的java.exe）。
    dvm是android的dalvik虚拟机，也就是android程序的运行时基于该虚拟机，起作用是将.java->.class->.dex，相比jvm的好处是将文件进行整合和处理。

2、art模式和dvm模式的区别。传统android程序运行dvm模式下，也就是程序运行需要借用dvm进行java程序到机器语言的过程。而art模式会将android程序提前进行
    预编译转换成机器语言，所以占用内存会增加，但是运行速度会变快。

9.22
1、View和ViewGroup的概念。android的UI以及界面的层次结构和ios还是有区别的。ios所有的ui控件都是继承自UIView，而android分为View和ViewGroup两类，
    ViewGroup继承自View。

9.24
1、LineLayout，线性布局。有点像Flutter中的Column和Row。其中重要的属性，weight、divide、layout_gravity和orientation。
2、TableLayout，注意配合TableRow使用。TableLayout是从上往下排列，TableRow是从左往右排列。其中重要的几个属性。xxxxColumns。

9.29
1、FrameLayout，帧布局的特点就是开辟一块控件，往里面放控件默认是会放在左上角，无法定位，所以使用场景不多。

10.9
1、RelativeLayout，相对布局现在用的比较少。需要注意几个属性:
    根据父容器：
        layout_alignParent-xxx 相对于父容器上、下、左、右对齐。
        layout_center-xxx 相对于父容器水平居中、垂直居中、整体居中。

    根据兄弟组件：
        layout_toLeftOf 参考左边
        layout_toRightOf 参考右边
        layout_above     上边
        layout_below     下边
        layout_align-xx  xx方向对齐

2、ConstraintLayout，现在使用表多的相对布局。相对于RelativeLayout，但是又比RelativeLayout性能更好，使用更加方便。

10.10
1、Context，上线文。首先我们应该明白其继承关系。
    Context直接子类，ContextWrapper（Context的封装），ContextImpl（Context的实现）。
        ContextWrapper有三个子类，ContextThemeWrapper、Service和Application。 其中ContextThemeWrapper的子类是Activity。
        我们常接触的就有Application、Service和Activity。所以他们都属于Context的子类，而Context功能的具体实现是由ContextImpl类实现的。
        因此大多数场景这三种Context是可以通用的。但是也有一些特殊情况，比如Dialog和Activity是不允许凭空出现的，必须要形成返回栈（这个和ios有点类似），
        因此这些场景就必须使用Activity类型的Context。
    所以一个应用程序的Context = Activity数量 + Service数量 + 1（Application）。注意ios中UIApplication也是一个（在UIApplicationMain函数中创建）。

    我们查看ContextWrapper源码就可以发现，其实内部有个Context mBase; 变量。而该变量是通过attachBaseContext(Context base)方法进行赋值的，而该
    方法由系统调用，并且参数是ContextImpl 对象。而ContextWrapper内部所有方法，都是通过mBase进行获取，所以我们说ContextWrapper内所有功能都是有ContextImpl
    实现的。 注意：其内部方法调用顺序： ContextWrapper() -> attachBaseContext(Context base) -> onCreate()。 所以我们要使用context的一些方法需要
    在onCreate方法里面调用最好。

    Context的使用场景：
    1、调用context的一些方法，比如startActivity，访问资源等。
    2、调用一些方法的时候需要作为参数，比如Toast、Dialog等。

2、Application。一个app只有一个application，其获取方式：
    如果activity内，通过getApplication、getApplicationContext获取。
    service可以通过ctx.getApplicationContext获取。

3、注意this和Activity.this的区别。 都是获取当前类的对象，this和ios中的self是一样的。
    xxx.this的调用前提是必须在xxx类中调用，不然会报xxx is not a enclosing class。

4、Intent。首先我们需要知道Intent包括显示Intent和隐式Intent。
     显示Intent很简单，直接调用就ok。

     隐式Intent。
     隐式顾名思义是不指定Activity，而是通过设置Action、Data、Category，让系统来筛选适合的Activity。
     筛选是根据所有的<intent-filter>来进行筛选。
     在manifest中对Activity进行intent-filter 进行配置。
     <action android:name="android.intent.action.Sy1"/>
     <category android:name="android.intent.category.DEFAULT"/>
     注意必须设置action和category。

     Intent有7大属性。Action（动作）、Category（类别）、Data（数据）、Type（数据类型）、
     Component（组件）、Extra（扩展信息）、Flag（标志位）。最常用的Action和Data。


     Action：表示动作的意图。系统提供了很多action。
     常见的ACTION_CALL、ACTION_DIAL两者间有区别 打电话。
     ACTION_SENDTO 发短信。
     ACTION_VIEW  打开网页。

     Category：表示动作的类别。
     常见的Category_Default， 如果要隐式启动Activity，需要将category设置成default。
     CATEGORY_LAUNCHER， 启动的第一个Activity。

     Type： 指定数据类型。
     一般Intent的数据类型能够数据本身进行判断，但是通过设置这个属性，可以强制采用显示指定而不用进行推导。

     Component：目的组件
     指定Intent的目标组件名称，当指定了这个属性后，系统将跳过匹配其他属性，而直接匹配这个属性来启动对应的组件。

     Extra：扩展信息
     Intent可以携带的额外 key-value 数据，你可以通过调用putExtra()方法设置数据，每一个 key对应一个 value数据。
     你也可以通过创建 Bundle对象来存储所有数据，然后通过调用putExtras()方法来设置数据。

     Flag：期望这个意图的运行模式
     用来指示系统如何启动一个Activity，可以通过setFlags()或者addFlags()可以把标签flag用在Intent中。

     总的来说打开系统的一些app都是基于Intent实现的。而ios是通过UIApplication来进行的。


10.12
1、生命周期。
    onCreate
    onRestart // 这个方法调用的特殊性
    onStart
    onResume
    onPause
    onStop(onStop是否调用还要看Activity是否显示在栈上面)
    onDestroy

2、启动模式。launchMode：主要有四种
    stander，标准模式，也是默认的模式，通过推栈的方式进行。
    singleTop，当设置该模式的Activity在栈顶的时候，如果在进行startActivity的时候，将不会重新开启。
    singleTask，主义和singleTop的区别，也就是如果设置该模式的Activity在task栈中，将不会重新创建新的activity。
        类似ios中popTo_xxx返回指定的vc。
    singleInstance，该模式的特点就是，将设置该模式的activity放置在新的task栈中，所以当今出现多层activity的时候，点击返回没在同一个栈
    中将不会出现。


3、退出程序。

    Java中byte也是基础数据类型，表示字节。有8位二进制表示。

4、TextView。
    常见属性：
    text、textSize、textStyle、gravity、text-xxxx。

    阴影：shadowRadius 也就是阴影的模糊程度，不设置则没有效果。
        shadowDx, shadowDy x\y轴偏移
        shadowColor 阴影颜色。

    边框样式： 需要编写drawable资源文件。
    <shape> 标签里面的元素并不多：
    <solid> 填充色。
    <corners> 圆角。

    drawable属性来进行图片设置。

    autoLink属性，可以对内容进行识别。

    ellipsize省略号位置。 和ios中lineBreakMode控制的一样效果。


10.13
1、EditText，输入框。继承自TextView。
        ios的输入框UITextField: UIControl， UITextView: UIScrollView。
        flutter直接是TextField。

    常用的属性：
    hint: 占位文字
    textColorHint: 占位颜色
    inputType: 键盘样式。 有很多样式，常用的password密码样式。 这点和ios有点区别，ios通过isSecuryEntry控制。

    selectAllOnFocus： 当获取焦点的时候，宣布选中。

    lines: 控制行数。默认是多行，类似ios中的UITextView，如果要是一行需要设置该属性，注意：设置单行时候需要配合inputType因为默认inputType
        是多行输入的。当然也可以借助singleLines属性，虽然该属性以及废弃。
    maxLines/minLines： 最多或者最少行。

    关于键盘，可以通过editText.requestFocus或者是clearFocus来进行键盘的显示和隐藏。
    Activity的 windowSoftInputMode属性，【一】当有焦点产生时，软键盘是隐藏还是显示【二】是否减少活动主窗口大小以便腾出空间放软键盘。

2、SpannableString 富文本，类似ios中NSAttributeString。

3、Button的样式控制，以及点击事件的控制需要通过Drawable资源文件来进行出来。
    关于Button的继承关系：
    Button->TextView->View->Object
    Button的直接子类ComponentButton，间接子类CheckBox、RadioButton、Switch、ToggleButton。

    Button常用属性并不多。其点击样式需要通过xml文件来进行配置。根节点是<selector>， 子节点是<item>
    item中:
    drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~
    state_pressed:控件是否被按下
    state_selected:控件是否被选择,针对有滚轮的情况。这些事最常用的。


4、注意visible属性的三个值的关系。 gone（隐藏并且不会占用空间）、invisible（隐藏但会占用空间）、visible。

5、ImageButton是继承自ImageView的。能够展示图片。

6、ImageView。ImageView中src和background的区别。
    src是表示内容，有图片，那么图片不会进行拉伸。
    background如果内部有图片会对图片进行拉伸。
    scaleType缩放类型。类似ios中contentModel。
        fitXY:对图像的横向与纵向进行独立缩放,使得该图片完全适应ImageView,但是图片的横纵比可能会发生改变
        fitStart:保持纵横比缩放图片,知道较长的边与Image的编程相等,缩放完成后将图片放在ImageView的左上角
        fitCenter:同上,缩放后放于中间;
        fitEnd:同上,缩放后放于右下角;
        center:保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。
        centerCrop:保持横纵比缩放图片,知道完全覆盖ImageView,可能会出现图片的显示不完全
        centerInside:保持横纵比缩放图片,直到ImageView能够完全地显示图片
        matrix:默认值，不改变原图的大小，从ImageView的左上角开始绘制原图， 原图超过ImageView的部分作裁剪处理

    maxHeight:
    maxWidth:
    adjustViewBounds: 当设置最大宽和最大高的时候，如果设置该属性表示调整缩放比例。

7、RadioButton。注：ios是没有该控件的。一般用于单选框。
    RadioButton是继承自ComponentButton extends Button。
    当单个使用的时候，如果是check = true的时候，其状态将不再改变。

    当实现单选效果，可以配合RadioGroup使用。RadioGroup是继承自LineLayout的。
    常用的几个方法：
    group.getChildCount()。 获取单选数量
    getChildAt(i)。根据索引值获取我们的单选按钮
    isChecked( ):判断按钮是否选中

    如果想要修改样式可以通过：button、drawableXx、paddingXx来进行控制。

8、CheckBox。注：ios 没有该控件。一般用于复选框。
    CheckBox和RadioButton很像，也是继承自ComponentButton extends Button。

    如果想要修改样式可以通过：button、drawableXx、paddingXx来进行控制。
    配合xml文件进行设置。
    如果不想要系统的按钮。可以通过button = "@null" 进行设置。

9、ToggleButton。同样继承ComponentButton extends Button。
    能设置的属性只有三个。
    textOn:
    textOff:
    disableAlpha:

10、Switch。同样继承ComponentButton extends Button。
    注意：直接或者间接继承Button的，都可以通过xml来进行资源文件的设置。


    android:showText：设置on/off的时候是否显示文字,boolean
    android:textOff：按钮没有被选中时显示的文字
    android:textOn：按钮被选中时显示的文字
    这是三个属性能控制thumb上面的文字。

    android:textStyle：文字风格，粗体，斜体写划线那些
    android:splitTrack：是否设置一个间隙，让滑块与底部图片分隔,boolean
    android:switchMinWidth：设置开关的最小宽度
    android:switchPadding：设置滑块内文字的间隔
    android:switchTextAppearance：设置开关的文字外观，暂时没发现有什么用...
    android:track：底部的图片
    android:thumb：滑块的图片

    像track和thumb属性很像ios中的UISwitch。


10.14
1、setOnClickListen是View的一个方法。

2、ProgressBar继承自View。
    其直接子类AbsSeekBar和ContentLoadingProgressBar。 其中AbsSeekBar的子类有SeekBar和RatingBar。
    默认是圆形进度条，而且有动画效果。类似ios中UIActivityIndicatorView : UIView。 注意和UIActivityViewController的区别。

    当然可以设置成线性的。这个时候类似ios中UIProgressView : UIView。

    重要属性。
    style 设置样式
    android:indeterminate：如果设置成true，则进度条不精确显示进度。而是现实水平方向转圈圈。
    android:max：进度条的最大值
    android:progress：进度条已完成进度值
    android:progressDrawable：设置轨道对应的Drawable对象
    android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过progress属性进行设置！


3、SeekBar拖动的进度条。类似ios中UISlide： UIControl。
    实际上ios中继承自UIControl的有UIButton、UITextField、UISlide、UISegmentControl、UIDatePicker。

4、RatingBar。注意RatingBar和SeekBar的样式修改，都是基于<layer-list> 节点实现的。并且配合使用style搭配使用才能起到效果。

    注意RatingBar、SeekBar、ProgressBar设置进度条样式都可以通过progressDrawable进行设置。

5、ScrollView滚动视图。类似ios中UIScrollView。但是其继承关系是不一样的。
    ScrollView extends FrameLayout extends ViewGroup
    我们可以发现ScrollView其实是继承自FrameLayout帧视图的。里面只能存放一个视图。

6、TextClock继承TextView，能够显示时间。
    其可用属性并不多。
    format12Hour 12小时制时间格式
    format24Hour 24小时制时间格式
    timeZone     时区

7、Chronometer倒计时文本。
    属性：
    format: 设置格式。"MM:SS" or "H:MM:SS"
    countDown： 是否倒计时   chronometer.setBase(SystemClock.elapsedRealtime());

8、DatePicker: FrameLayout 日期选择器。ios中UIDatePicker类似。
    属性：
    datePickerMode 有两种样式。spinner和calendar 两者间的区别
   TimerPicker: FrameLayout 时间选择器
   CalendarView: FrameLayout 日历

9、AlertDialog对话框。类似ios总UIAlertController(配合UIAlertAction使用)。
    new AlertDialog.Builder 普通对话框。
    常用属性：
    setTitle
    setMessage
    setCancelable
    setxxxButton

    // 单选对话框
    setSingleChoiceItems
    // 复选框
    setMultiChoiceItems
    // 自定义对话框
    setView

    ProgressDialog: AlertDialog。目前废止。
    new ProgressDialog(this) 进行初始化。

    DatePickerDialog: AlertDialog。日期选择
    new DatePickerDialog(this) 进行初始化。

10、关于Android studio的几个常用配置。
    show parameter hints on completion 设置。
    editor -> general -> code completion -> Match Case 去掉。

11、PopUpWindow对话框相对于AlertDialog的区别。主要是可以设置位置。
    重要方法：
    setContentView
    showAsDrop

12、Menu。android中常用的有三种菜单。
    1、OptionMenu 选项菜单。也是最常见的菜单。
    2、SubMenu 子菜单。
    3、ContextMenu 上线文菜单。

    OptionMenu是通过重写方法实现的。
    onCreateOptionsMenu  创建
    onOptionsItemSelected item选择

    ContextMenu在onCreate中对列表进行注册
               registerForContextMenu(recyclerView);
               在onDestroy中对列表进行解绑
               unregisterForContextMenu(recyclerView);

    一般通过xml的形式来进行创建。 常见的几个标签<menu> <item> <group>。 其实group是对item不可见封装。
    通过设置group来使得内部共用group属性。


10.16
1、PercentLayout百分比布局。当然android以及遗弃了。

2、ConstraintLayout。官方推荐使用0dp表示match_parent

    其属性都是
    layout_constraint开头
    layout_constraintBaseline_toBaselineOf 文本基线。
    layout_goneMarginLeft   当相对定属性设置为gone时，该属性起作用。
    layout_constraintCircle 设置相对于点的圆角显示。

    layout_constraintHorizontal_bias
    layout_constraintVertical_bias
    这连个属性需要配合的前提是居中，表示偏移。

    minWidth
    maxWidth 最小和最大宽度

    layout_constraintDimensionRatio 设置宽高比

    // 链。
    layout_constraintHorizontal_chainStyle来改变整条链的样式。chains提供了3种样式，分别是：
    CHAIN_SPREAD —— 展开元素 (默认)；
    CHAIN_SPREAD_INSIDE —— 展开元素，但链的两端贴近parent；
    CHAIN_PACKED —— 链的元素将被打包在一起。

    // 辅助工具
    Barrier
    通过设置barrier来进行控制。 ios中可以通过设置优选级来实现。
    Barrier其实是继承ConstraintHelper ： View。也就是说Barrier是间接继承View的。
    但是其属性并不会起作用。
    属性：
    constraint_referenced_ids 设置引用
    barrierDirection 方向

    // Group组。可以将制定控件组成组。
    // Placeholder 通过content，将控件置为placeholder位置。
    // Guideline 辅助线。


10.19
1、关于android中xml布局文件的几个标识：
    xmlns:android="http://schemas.android.com/apk/res/android"
     有了他，Android Studio就会在我们编写布局文件的时候给出提示，提示我们可以输入什么，不可以输入什么。也可以理解为语法文件，或者语法判断器。

    xmlns:app="http://schemas.android.com/apk/res-auto"  在项目中，我们往往使用系统自带的属性和控件还不够，我们可能
        需要导入自定义控件的一些属性，或者support支持包之类的。就需要添加这句话。

    xmlns:tools="http://schemas.android.com/tools" 可以告诉android studio，哪些属性在运行时候是被忽略的，只是在设计的时候
        起作用。tools可以覆盖android的所有标准属性，将android:换成tools:即可；同时在运行的时候就连tools:本身都是被忽略的，不会被带进apk中。

    其中xmlns是指xml name space。即xml的命名空间。

2、关于像素知识。
    分辨率对应的dpi。
    "HVGA     mdpi"
    "WVGA     hdpi "
    "FWVGA    hdpi "
    "QHD      hdpi "
    "720P     xhdpi"
    "1080P    xxhdpi "

    px。像素，不用说。我们常见的1080*1920就是指的是px，而且像素都是以整数出现，每个像素表示一个点。
    in。表示英寸（inch），是屏幕的物理尺寸。每英寸 = 2.54厘米。我们常说的手机屏幕就是使用的这个单位。比如5英寸 = 5 * 2.54cm = 12.5cm
        具体是指对角线长度。
    dpi。表示dots per inch的缩写。每英寸的点数，即每英寸包含的像素点。比如320X480分辨率的手机，宽2英寸，高3英寸,
        每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，
        原因是大部分手机屏幕使用正方形的像素点。
    density。表示屏幕密度。density和dpi的关系为 density = dpi/160。
    dp。设备的独立像素。类似ios中pt，1pt = 0.17mm，是固定长度，而且需要根据设置scale进行像素转换，px = pt * scale。
    sp。和dp很类似，之所有引进sp，是为了根据用户字体大小偏好进行设置。

3、android中的View直接集成了一些事件。比如点击等。

4、Adapter适配器。我们使用ListView和GridView都会使用是配置。
    首先我们需要知道其继承关系。
    Adapter(interface)
        ListAdapter(interface)
            WrapperListAdapter(interface)
                HeaderListAdapter
        SpinnerAdapter(interface)
            BaseAdapter(抽象类，用的最多的一个类，实际开发中我们会自定义类继承BaseAdapter）
                CursorAdapter
                    ResourceCursorAdapter
                        SimpleCursorAdapter
                ArrayAdapter（只能展示一行文字）
                SimpleAdapter（可以自定义多种效果）



5、Android 作用域。
    关键字        当前类            同一package        子孙类       其他package
    public         √                    √             √                  √
    protected      √                    √             √                  ×
    friendly(默认)  √                    √             ×                  ×
    private        √                    ×             ×                  ×

    从上面的作用域可以看出。和swift的作用域的对比。
    private    private
    friendly   internal
    protected  public
    public     open


10.26
1、ListView。类似ios中的UITableView : UIScrollView。
    继承关系。
    ListView : AbsListView : AdapterView : ViewGroup : View : Object
    RecycleBin是AbsListView的内部类，也是复用的控制中心，正是RecycleBin的存在让ListView有了复用的能力。

2、GridView。类似ios中UICollectionView。

3、ScrollView 和 HorizonScrollView。 类似ios中的UIScrollView。
    特性：就是ScrollView内部需要一个控件。有点类似flutter中的SingleScrollView。

4、RecycleView。隶属于v7包。
    重要方法。
    setLayoutManager： 有三种LayoutManager：LineLayoutManager、GridLayoutManager、StaggeredGridLayoutManager（瀑布流）。

    setAdapter: 添加适配器。注意这里和BaseAdapter的区别。

    addItemDecoration: 给item添加装饰。可以给item添加分割线。
        ItemDecoration是抽象类，有三个方法：
        onDraw: 在item的下面绘制。
        onDrawOver： 在item的上面绘制。
        getItemOffsets：在item的offset位置绘制。该方法可以添加分割线。


5、Android中的Bundle是用来对数据进行封装，然后进行数据传递的。如：Intent到Intent，或者Intent到Fragment。
    ios中NSBundle是用来表示包的内容。
    我们通过NSBundle.main.pathxxxxx。可以获取当前包（也就是app的内容）。
    ios中NSBundle是获取文件路径的。

11.5
1、Fragment是一种可以嵌入在活动中的UI片段，能够让程序更加合理和充分地利用大屏幕的空间，出现的初衷是为了
适应大屏幕的平板电脑，可以将其看成一个小型Activity，又称作Activity片段。
    其优势：
    a、模块化：不需要把代码全部写在Activity中，而是把代码写在各自的fragment中。
    b、可重用：多个Activity可以重用一个Fragment。
    其实由于ios的设计，所以ios中每个UIViewController就可以看做是一个Fragment。可以通过view.add(childVc.view)来进行
    添加view。同时通过vc.addChirld(childVc)来添加子控制器。

2、Fragment加载分为两种，静态和动态。
    静态通过是用fragment标签加载。
    动态最常用：
    1、getSupportFragmentManager(); 获取FragmentManager，是用来管理Activity中的Fragment的。
        常见方法，fragmentMng.findFragmentByTag\id来进行查询。
    2、fragment.beginTransition(); 获取FragmentTransition，事务，用来添加、移除、替换Fragment。
        transition.add(); 添加。 // fragment进行一轮生命周期。
        transition.remove(); 移除。  // 移除生命周期，知道fragment调用deAttach();结束。 fragment、view都销毁
        transition.replace(); 替换。 // a.remove(); b.add(); 也就是a先移除，b在添加。
        transition.hidden(); 隐藏。  // a.onHiddenChanged方法。 fragment、view都不销毁
        transition.show(); 显示。    // a.onHiddenChanged方法。  fragment、view都不销毁
        transition.deAttach();       // fragment并不会完全销毁，而是调用onDestroyView()方法来销毁view层级
        transition.attach();         //  调用onCreateView来创建view。
        transition.commit(); 提交一个事务。
    3、注意每次做一次操作都需要重新获取事务，和提交事务。

3、Fragment传递数据。分三种情况。
    1、Activity向Fragment传递。
        最简单，通过newInstance方法传递。 因为Fragment不能重写构造方法。

    2、Fragment向Activity传值。
        a.getActivity().xxxx进传值。(不建议)。
        通过interface传值。
        android的interface和oc的protocol有点类似，

    3、Fragment向Fragment传值。
        a.getActivity();
        activity.getSupportFragmentManager();
        mng.findFragmentByxx()；
        然后进行传值。

4、回退栈。backStack。
    前提是通过addToBackStack经Fragment添加回退站中。

11.10
1、debug和release的区别。和ios类似，通过run模式其实就是debug模式，所用到的签名、配置信息都是debug模式。通过打包release生成release包。
2、debug和release的签名。

    这和ios有很大区别。ios签名需要签名证书。而且debug证书和release证书是不能相同的，创建方式也不一样。
    android的签名只需要配置.jks文件。而且可以debug和release使用相同的签名文件。那么需要两种签名文件的意义就在于：
    比如在使用第三方sdk（分享、友盟等）时候，需要申请密钥，而申请密钥就需要提供相应签名文件的sh1.这样只有通过该签名文件打包的apk才能使用
    相应的sdk文件。

    如果我们项目什么都不做，那么项目只会有一个默认的debug.jks文件，如下：
    想要替换默认的keystore，那么你的keystore的密码、别名等信息必须和默认debug.keystore的一样，默认debug.keystore的信息如下：
    Keystore name: “debug.keystore”
    Keystore password: “android”
    Key alias: “androiddebugkey”
    Key password: “android”
    CN: “CN=Android Debug,O=Android,C=US”

    android并不会给我们提供release.jks。
    而进行签名的好处就是：
    1、应用升级，因为一个签名文件对应一个包名，而只有同一个包名，系统才会允许升级。如果使用不同的签名，那么android就需要使用
    不同的包名，那么实际上安装在手机上就是不同的程序。
    2、应用程序模块化。
    3、代码数据共享。



3、事件响应。

    基于监听的事件处理：
    a、事件源
    b、接听器
    c、事件
    实现方法。1、通过内部类实现。 2、通过匿名内部类。 3、通过事件源所在类实现。 4、通过外部类。 5、布局中onClick属性。
    当给同种同一个事件源添加事件，最后一个有效。

    基于回调的事件处理：

4、ios中，NSBundle其实和android中的PackageManager一样，用来读取ipa或者apk中的数据。

5、android多渠道打包。android签名包括v1、v2和v3。v1是基于jar，是全版本的。v2是android 7.0的签名方案，v3是9.0方案。


11.13
1、Handler的使用。Handler牵扯到几个重要的类。
    Handler：快递员（属于某个快递公司的职员）
    Message：包裹（可以放置很多东西的箱子）
    MessageQueue：快递分拣中心（分拣快递的传送带）
    Looper：快递公司（具有处理包裹去向的管理中心）

   Handler常用场景：
   1、主线程更新UI。
   2、指定消息通知。

   使用方式。post和sendMsg两种方式。

2、Android中的多线程。android中操作多线程有四种方法（ios有三种Thread、OperationQueue、GCD）：
    Runnable是一个接口，里面有run（）方法。
    Runnable是一个线程辅助类，而真正创建线程的是Thread类。
    注意Thread实现了Runnable接口，所以有run方法。但是实际上我们开启线程是通过thread.start()。开启。

    1、Handler+Thread。
    2、AsyncTask。
    3、ThreadPoolExecutor。
    4、IntentService

11.17
1、BroadcastReceive广播接收者。类似ios中NSNotificationCenter。

2、android中的手势Gesture。手势交互过程：
    1.手指触碰屏幕时，触发MotionEvent事件！
    2.该事件被OnTouchListener监听，可在它的onTouch()方法中获得该MotionEvent对象！
    3.通过GestureDetector转发MotionEvent对象给OnGestureListener
    4.我们可以通过OnGestureListener获得该对象，然后获取相关信息，以及做相关处理！

    其中MotionEvent是手势对象。类似ios中Event。
    GestureDetector：识别各种手势。类似ios中Gesture。
    OnGestureListener： 手势交互的各种api。

11.18
1、IntentFilter。Intent过滤器。 Intent的意图。
    我们使用Intent的时候，设置的action、category等，最后都是设置到IntentFilter中。

2、Service。属于四大组件：所以使用的使用需要在manifest里面注册。
   我们需要了解程序、进程、线程的区别。
   程序就是一堆静态代码。
   进程就是运行的程序。
   线程就是比进程更小的执行单元，每个进程可能有多个线程，线程需要放在进程中才能执行。

   注意和线程的区别。
   android和ios的后台机制：
   ios：切换到后台后程序就会停止（一般有5s左右的缓冲事件，程序员可以进行延长）。当我们点击home键的时候，看到的其实是我们
   浏览程序的记录（这也是以前qq切换到后台不能收到消息的原因，当然现在ios采用通知的方式来解决这个问题）。所以哪怕我们是在循环遍历一些操作也会停止。
   android：应用在被切换到后台时，它其实已经被暂停了，并不会消耗cpu资源，只保留了运行状态。而且android运行需要虚拟机，这也是安卓程序更占内存的原因。

   Service的生命周期，主要有三个方法：
   onCreate：
   onStartCommand:
   onDestroy:

   Service开启后并不会自动停止。

   Service启动的方式：
   1、通过startService启动。
        通过startService启动，我们如果不调用stopService，那么该服务将一直运行。哪怕我们将activity销毁，service也不会销毁。
        onCreate->startCommand->onDestroy
   2、通过bindService启动。
        通过bindService启动，如果我们不调用unBinder，那么当activity销毁，将会报错。
        onCreate->onBind->onUnBind->onDestroy  不能够多次绑定。

11.20
1、android studio快捷键。
    alt + enter   错误提示。
    cmd + p   参数提示。
    option + cmd + f  快速价格变量抽成成员变量。

2、android AIDL。


12.07
1、ContentProvider

11.10
1、获取本地app的路径。data/data/包名/xxxxxxxx。
    在实际开发中，我们一般不会操作改路径，因为该路径可能出现改变。我们应该使用context来操作问价。




